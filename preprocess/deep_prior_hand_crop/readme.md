# Hand crop

This is the explanation of the deep prior hand crop process
- define the cube size and the cropped image size dsize

- load annotation file and read every line

- go through every image grame by a for loop

- get the groudtruth (list label; numpy array gt3Dorig) of each keypoint

- get keypoints in uvd from 3D groundtruth xyz in the camera coordinates by joints3DToImg()

    $u = Xc/Zc * fx + ux $ \
    $u = Yc/Zc * fy + uy$
    
- calculate center of mass uvd
    - scipy.ndimage.center_of_mass(input, labels=None, index=None)
    - Calculate the center of mass of the values of an array at labels.
    
    - Parameters
    - inputndarray.
      - Data from which to calculate center-of-mass. The masses can either be positive or negative.
    
    - labelsndarray, optional
      - Labels for objects in input, as generated by ndimage.label. Only used with index. Dimensions must be the same as input.
    
    - indexint or sequence of ints, optional
      - Labels for which to calculate centers-of-mass. If not specified, all labels greater than zero are used. Only used with labels.
    
    - Returns center_of_masstuple, or list of tuples
       - Coordinates of centers-of-mass.
 
 -  based on the defined cube size and the mass center to Calculate xyz boundaries, project to 3D, 
    then add offset and backproject to 2D (ux, uy are canceled)
    
 - Crop patch from image based on the xyz boundaries
 
 - id docom(double com) is true, calculateCoM of cropped cube again, then crop again
 
 - based on the width and legnth of the cropped cube, decide if need to resize and crop to dsize cube
 
 - get center of the mass xyz from center of mass uvd
 
 - get new groundthruth based on new center of mass
 
 - normalize the depth of the image to [-1, 1]
 
    - make the depth of pixels, which equal to zero, from 0 to the back depth of the cube
    - all pixels minus the z of center of mass
    - all pixels divide the size of the cube